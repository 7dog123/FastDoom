#include <stdlib.h>
#include <dos.h>
#include <conio.h>
#include "ns_dpmi.h"
#include "ns_task.h"
#include "ns_cards.h"
#include "ns_user.h"
#include "ns_ac97.h"
#include "ns_muldf.h"
#include "ns_inter.h"
#include "ns_multi.h"
#include "ns_pci.h"

#include "m_misc.h"
#include "options.h"
#include "doomstat.h"

static int AC97_Installed = 0;

static short *AC97_BufferStart;
static short *AC97_CurrentBuffer;
static int AC97_BufferNum = 0;
static int AC97_NumBuffers = 0;
static int AC97_TransferLength = 0;
static int AC97_CurrentLength = 0;

unsigned short AC97_Port = 0x220;

static short *AC97_SoundPtr;
volatile int AC97_SoundPlaying;

static task *AC97_Timer;

void (*AC97_CallBack)(void);

unsigned judascfg_port = -1;

/*---------------------------------------------------------------------
 Function: AC97_ServiceInterrupt

 Handles interrupt generated by sound card at the end of a voice
 transfer.  Calls the user supplied callback function.
 ---------------------------------------------------------------------*/

static void AC97_ServiceInterrupt(task *Task) {
	char *ptr = AC97_SoundPtr;

	unsigned char value1 = (unsigned char) *(ptr);
	unsigned char value2 = (unsigned char) *(ptr + MV_RightChannelOffset);

	// ???

	AC97_SoundPtr++;

	AC97_CurrentLength--;
	if (AC97_CurrentLength == 0) {
		// Keep track of current buffer
		AC97_CurrentBuffer += AC97_TransferLength;
		AC97_BufferNum++;
		if (AC97_BufferNum >= AC97_NumBuffers) {
			AC97_BufferNum = 0;
			AC97_CurrentBuffer = AC97_BufferStart;
		}

		AC97_CurrentLength = AC97_TransferLength;
		AC97_SoundPtr = AC97_CurrentBuffer;

		// Call the caller's callback function
		if (AC97_CallBack != NULL) {
			MV_ServiceVoc();
		}
	}
}

/*---------------------------------------------------------------------
 Function: AC97_StopPlayback

 Ends the transfer of digitized sound to the Sound Source.
 ---------------------------------------------------------------------*/

void AC97_StopPlayback(void) {
	if (AC97_SoundPlaying) {
		TS_Terminate(AC97_Timer);
		AC97_SoundPlaying = 0;
		AC97_BufferStart = NULL;
	}
}

/*---------------------------------------------------------------------
 Function: AC97_BeginBufferedPlayback

 Begins multibuffered playback of digitized sound on the Sound Source.
 ---------------------------------------------------------------------*/

int AC97_BeginBufferedPlayback(char *BufferStart, int BufferSize,
		int NumDivisions, void (*CallBackFunc)(void)) {
	if (AC97_SoundPlaying) {
		AC97_StopPlayback();
	}

	AC97_CallBack = CallBackFunc;

	AC97_BufferStart = BufferStart;
	AC97_CurrentBuffer = BufferStart;
	AC97_SoundPtr = BufferStart;
	// VITI95: OPTIMIZE
	AC97_TransferLength = (BufferSize / NumDivisions) / 2;
	AC97_CurrentLength = AC97_TransferLength;
	AC97_BufferNum = 0;
	AC97_NumBuffers = NumDivisions;

	AC97_SoundPlaying = 1;

	AC97_Timer = TS_ScheduleTask(AC97_ServiceInterrupt, AC97_SampleRate, 1,
			NULL);
	TS_Dispatch();

	return (AC97_Ok);
}

/*---------------------------------------------------------------------
 Function: AC97_Init

 Initializes the Sound Source prepares the module to play digitized
 sounds.
 ---------------------------------------------------------------------*/

int AC97_Init(int soundcard, int port) {
	int device;

	if (AC97_Installed) {
		AC97_Shutdown();
	}

	if (pci_check_bios() == FALSE) {
		printf("Error : PCI BIOS not found.\n");
		return AC97_Error;
	}
	device = 0;
	while (audio_dev_list[device].vender_id != 0x0000) {
		audio_pci.vender_id = audio_dev_list[device].vender_id;
		audio_pci.device_id = audio_dev_list[device].device_id;
		audio_pci.sub_vender_id = audio_dev_list[device].sub_vender_id;
		audio_pci.sub_device_id = audio_dev_list[device].sub_device_id;
		if (pci_find_device() == TRUE) {
			printf("%s found.\n", audio_dev_list[device].string);
			break;
		}
		device++;
	}
	if (audio_dev_list[device].vender_id == NULL) {
		printf(
				"Error : AC97/HDA Audio Codec compatible device could not be found.\n");
		return AC97_Error;
	}

	// save device info
	audio_pci.device_type = audio_dev_list[device].type;
	strcpy(audio_pci.device_name, audio_dev_list[device].string);

	// read pci configuration
	audio_pci.command = pci_config_read_word(PCI_COMMAND);
	audio_pci.irq = pci_config_read_byte(PCI_INTERRUPT_LINE);
	audio_pci.pin = pci_config_read_byte(PCI_INT_LINE);
	audio_pci.base0 = pci_config_read_dword(PCI_BASE_ADDRESS_0); // NAMBAR
	audio_pci.base1 = pci_config_read_dword(PCI_BASE_ADDRESS_1); // NABMBAR

    printf("AC97/HDA Audio Codec PCI IRQ at %d\n", audio_pci.irq);
    printf("AC97/HDA Audio Codec IRQ PIN nr %d\n", audio_pci.pin);

	// if memory type IO is enabled then use memory type IO (other manufacturers)
	if (audio_pci.command & PCI_COMMAND_MEMORY)
		audio_pci.mem_mode = 1;

	// start configuring devices
	switch (audio_pci.device_type) {
	case DEVICE_INTEL_ICH4:
		// try to go for memory type IO as default for ICH4+ Intel controllers even if disabled in PCI command config
		audio_pci.mem_mode = 1;
		break;
	case DEVICE_NFORCE:
		pci_config_write_dword(0x4c, pci_config_read_dword(0x4c) | 0x1000000);
		break;

	case DEVICE_HDA_INTEL:
		audio_pci.hda_mode = 1;
		audio_pci.mem_mode = 1;
		break;
	case DEVICE_HDA_ATI:
		audio_pci.hda_mode = 1;
		audio_pci.mem_mode = 1;
		// enable snoop for ATI SB450 Azalia HD Audio
		pci_config_write_byte(0x42, (pci_config_read_byte(0x42) & 0xf8) | 0x2);
		break;
	case DEVICE_HDA_NVIDIA:
		audio_pci.hda_mode = 1;
		audio_pci.mem_mode = 1;
		// enable snoop for nVidia Azalia HD Audio
		pci_config_write_byte(0x4e, (pci_config_read_byte(0x4e) & 0xf0) | 0x0f);
		break;
	case DEVICE_HDA_SIS:
		audio_pci.hda_mode = 1;
		audio_pci.mem_mode = 1;
		break;
	case DEVICE_HDA_ULI:
		audio_pci.hda_mode = 1;
		audio_pci.mem_mode = 1;
		pci_config_write_word(0x40, pci_config_read_word(0x40) | 0x10);
		pci_config_write_dword(PCI_MEM_BASE_ADDRESS_1, 0);
		break;
	case DEVICE_HDA_VIA:
		audio_pci.hda_mode = 1;
		audio_pci.mem_mode = 1;
		break;

	default:
		break;
	}

	// HDA configuration
	if (audio_pci.hda_mode) {
		audio_pci.base0 = pci_config_read_dword(PCI_MEM_BASE_ADDRESS_0); // AZBAR
		audio_pci.base0 &= ~7;

		printf("HDA Audio Codec PCI BASE0 at I/O %04X\n", audio_pci.base0);

		// map linear memory - convert physical address to linear address
		if (!DPMI_MapMemory((unsigned long*) &audio_pci.base0,
				(unsigned long*) &audio_pci.base0, 0x4000))
			audio_pci.mem_mode = 0;

		// enable memory, IO and bus master - activate the device
		audio_pci.command |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
		pci_config_write_word(PCI_COMMAND, audio_pci.command);

		// Clear bits 0-2 of PCI register TCSEL (Traffic Class Select Register at offset 0x44)
		// Ensuring these bits are 0 clears playback static on some Azalia HD Audio codecs
		pci_config_write_byte(0x44, pci_config_read_byte(0x44) & 0xf8);

		// HDA config done now we need to initialize the codec

		// AC97 configuration
	} else {
		// get I/O base0 port - this is the Audio Mixer base port
		audio_pci.base0 = pci_config_read_dword(PCI_BASE_ADDRESS_0); // NAMBAR
		// Remove I/O space marker in bit 0
		audio_pci.base0 &= ~0xf;

		printf("AC97 Audio Codec PCI BASE0 at I/O %04X\n", audio_pci.base0);

		// get I/O base1 port - this is the Bus Master base port
		audio_pci.base1 = pci_config_read_dword(PCI_BASE_ADDRESS_1); // NABMBAR
		// Remove I/O space marker in bit 0
		audio_pci.base1 &= ~0xf;
		judascfg_port = audio_pci.base1;

		printf("AC97 Audio Codec PCI BASE1 at I/O %04X\n", audio_pci.base1);

		// get memory mapped IO for ICH4+ and other new chips
		if ((audio_pci.base0 == 0) || (audio_pci.mem_mode)) {
			audio_pci.base2 = pci_config_read_dword(PCI_MEM_BASE_ADDRESS_2); // NAMBAR
			audio_pci.base3 = pci_config_read_dword(PCI_MEM_BASE_ADDRESS_3); // NABMBAR

			// map linear memory - convery physical address to linear address
			if (!DPMI_MapMemory((unsigned long*) &audio_pci.base2,
					(unsigned long*) &audio_pci.base2, 0x1000))
				audio_pci.mem_mode = FALSE;
			if (!DPMI_MapMemory((unsigned long*) &audio_pci.base3,
					(unsigned long*) &audio_pci.base3, 0x1000))
				audio_pci.mem_mode = FALSE;

			// for information purposes only
			if (audio_pci.mem_mode)
				judascfg_port = audio_pci.base3;
		}

		// legacy I/O access
		if (audio_pci.mem_mode == FALSE) {
			if (audio_pci.device_type == DEVICE_INTEL_ICH4) {
				// enable the IOSE bit in 0x41 for legacy mode for ICH4/ICH5
				pci_config_write_byte(PCI_ICH4_CFG_REG, 1);
				// Set the secondary codec ID
				pci_config_write_byte(PCI_COMMAND_PARITY, 0x39);
			}

			// enable IO and bus master
			audio_pci.command |= PCI_COMMAND_MASTER | PCI_COMMAND_IO;
			pci_config_write_word(PCI_COMMAND, audio_pci.command);
		} else {
			//  enable port IO access compatibility even though we're going for memory mapped IO !!!
			if (audio_pci.device_type == DEVICE_INTEL_ICH4) {
				// enable the IOSE bit in 0x41 for legacy mode for ICH4/ICH5
				pci_config_write_byte(PCI_ICH4_CFG_REG, 1);
				// Set the secondary codec ID
				pci_config_write_byte(PCI_COMMAND_PARITY, 0x39);
			}

			// enable memory, IO and bus master
			audio_pci.command |= PCI_COMMAND_MASTER | PCI_COMMAND_IO
					| PCI_COMMAND_MEMORY;
			pci_config_write_word(PCI_COMMAND, audio_pci.command);
		}

		// AC97 config done now we need to initialize the codec
	}

	// test if both I/O range and memory mapped range are NULL
	// note : memory range address will be NULL if DPMI_MapMemory function fails for some reason
	if ((audio_pci.base0 == 0) && (audio_pci.mem_mode == 0)) {
		printf("Error : AC97/HDA normal I/O and memory mapped I/O access failed!\n");
		if (audio_pci.base0)
			DPMI_UnmapMemory((unsigned long*) &audio_pci.base0);
		if (audio_pci.base2)
			DPMI_UnmapMemory((unsigned long*) &audio_pci.base2);
		if (audio_pci.base3)
			DPMI_UnmapMemory((unsigned long*) &audio_pci.base3);
		return AC97_Error; // still DEV_NOSOUND at this point
	}

	if ((audio_pci.base0 == 0) && (audio_pci.base2 == 0)) {
		printf("Error : AC97/HDA Audio Codec device found, but disabled.\n");
		if (audio_pci.base0)
			DPMI_UnmapMemory((unsigned long*) &audio_pci.base0);
		if (audio_pci.base2)
			DPMI_UnmapMemory((unsigned long*) &audio_pci.base2);
		if (audio_pci.base3)
			DPMI_UnmapMemory((unsigned long*) &audio_pci.base3);
		return AC97_Error; // still DEV_NOSOUND at this point
	}

	AC97_SoundPlaying = 0;

	AC97_CallBack = NULL;

	AC97_BufferStart = NULL;

	if (port != -1)
		AC97_Port = port;

	AC97_Installed = 1;

	return (AC97_Ok);
}

/*---------------------------------------------------------------------
 Function: AC97_Shutdown

 Ends transfer of sound data to the Sound Source.
 ---------------------------------------------------------------------*/

void AC97_Shutdown(void) {
	AC97_StopPlayback();

// ???

	AC97_SoundPlaying = 0;

	AC97_BufferStart = NULL;

	AC97_CallBack = NULL;

	AC97_Installed = 0;
}
